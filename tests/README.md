# 交通信号控制机帧处理测试脚本说明文档

## 概述

本文档描述了 `tests/frame_processing_test.c` 测试脚本的功能、用途和使用方法。该测试脚本专门用于验证交通信号控制机的帧处理能力，确保在各种网络传输条件下都能正确解析和处理协议帧。

## 测试目的

验证 GB/T 43229-2023 交通信号控制机与车辆检测器通信协议的帧处理功能，特别是在以下场景下的鲁棒性：

1. **正常单帧传输**
2. **TCP粘包处理**
3. **跨包不完整帧处理**
4. **噪声/垃圾数据抗干扰**
5. **异常帧恢复机制**

## 测试用例详解

### 测试用例1：单帧正常传输

**测试目标**：验证标准协议帧的正确编码、传输和解析

**测试步骤**：
1. 创建心跳响应帧（包含设备标识、操作类型、对象标识等）
2. 使用 `encode_frame()` 将帧编码为字节流
3. 模拟网络接收，将字节流放入接收缓冲区
4. 使用 `extract_complete_frame()` 提取完整帧
5. 使用 `decode_frame()` 解码并验证帧内容

**验证要点**：
- 帧编码成功
- 能够提取到完整帧
- 帧开始位置和长度正确
- 解码后的操作类型、对象标识、内容长度等字段正确

### 测试用例2：双帧紧邻粘连

**测试目标**：验证TCP粘包场景下的帧分离能力

**测试步骤**：
1. 创建心跳响应帧和实时数据上传帧
2. 将两个帧编码后紧邻连接在一起（模拟粘包）
3. 模拟接收处理，验证能分离出两个独立的帧

**验证要点**：
- 能够从粘连数据中提取出两个完整帧
- 每个帧的内容都正确解析
- 粘包不影响帧的完整性

### 测试用例3：跨包不完整帧

**测试目标**：验证帧跨越多个网络包时的处理能力

**测试步骤**：
1. 创建一个测试帧并编码
2. 模拟第一次只接收到帧的前半部分
3. 验证此时无法提取到完整帧
4. 模拟第二次接收剩余数据
5. 验证能够提取和解码完整帧

**验证要点**：
- 不完整数据时正确返回"无完整帧"
- 数据补全后能够正确提取完整帧
- 跨包数据的完整性保持正确

### 测试用例4：含无效前缀噪声/垃圾字节

**测试目标**：验证抗噪声干扰能力

**测试步骤**：
1. 创建正常的测试帧
2. 在帧前面添加随机噪声数据
3. 验证能够跳过噪声数据找到真正的帧开始

**验证要点**：
- 能够跳过前缀噪声数据
- 正确定位真实帧的开始位置
- 噪声环境下帧解码依然成功

### 测试用例5：超长帧/异常帧丢弃与恢复

**测试目标**：验证异常帧处理和错误恢复机制

**测试步骤**：
1. 创建包含噪声的异常数据和正常帧的混合数据
2. 验证能够跳过异常数据提取正常帧
3. 模拟CRC校验错误的情况
4. 验证CRC错误检测和后续帧的正常处理

**验证要点**：
- 能够跳过异常数据找到正常帧
- CRC错误能够被正确检测
- CRC错误不影响后续正常帧的处理

## 编译和运行

### 编译测试程序

```bash
# 编译所有组件和测试程序
make all

# 或者只编译测试程序
make bin/frame_processing_test
```

### 运行测试

```bash
# 运行帧处理测试
make test-frame

# 或者直接运行可执行文件
./bin/frame_processing_test
```

### 清理构建文件

```bash
make clean
```

## 测试输出解释

测试程序会输出详细的测试过程和结果：

- `[PASS]`：测试通过
- `[FAIL]`：测试失败  
- 十六进制数据显示：显示编码后的帧数据，便于调试
- 统计信息：显示总测试数、通过数、失败数和通过率

### 成功输出示例

```
=== 交通信号控制机帧处理测试脚本 ===
测试开始时间：Fri Aug 29 03:37:46 2025

=== 测试用例1：单帧正常传输 ===
[PASS] 帧编码成功
编码后的帧数据 (28 bytes): C0 00 00 56 34 12 01 00 01 00 56 34 12 02 00 02 
00 10 83 01 01 01 02 03 04 C2 41 C0 
[PASS] 成功提取到完整帧
...

=== 测试结果统计 ===
总测试数：28
通过数：28
失败数：0
通过率：100.00%

🎉 所有测试通过！帧处理功能工作正常。
```

## 代码结构

### 主要函数

- `run_all_tests()`：主测试函数，运行所有测试用例
- `test_single_frame_normal()`：单帧正常传输测试
- `test_adjacent_dual_frames()`：双帧粘连测试
- `test_incomplete_cross_packet_frame()`：跨包不完整帧测试
- `test_invalid_prefix_noise()`：噪声干扰测试
- `test_oversized_abnormal_frame_recovery()`：异常帧恢复测试

### 辅助函数

- `create_test_frame()`：创建测试用协议帧
- `print_hex_data()`：打印十六进制数据，便于调试
- `TEST_ASSERT()`：测试断言宏，用于验证测试条件

## 技术要点

### 帧格式

协议帧采用以下格式：
```
| FRAME_START | 转义编码的数据表 | CRC16 | FRAME_END |
|    0xC0     |      数据      | 校验码 |   0xC0   |
```

### 转义编码

为避免数据中的 0xC0 与帧边界标识冲突，采用转义编码：
- 0xDB 0xDC → 0xC0（帧开始/结束标识）
- 0xDB 0xDD → 0xDB（转义字符本身）

### CRC校验

使用CRC16校验算法确保数据完整性，校验范围包括整个数据表（不包括帧开始/结束标识）。

## 扩展和维护

### 添加新测试用例

1. 在测试文件中创建新的测试函数
2. 在 `run_all_tests()` 中调用新函数
3. 使用 `TEST_ASSERT()` 宏进行验证
4. 更新本文档说明

### 调试建议

1. 使用 `print_hex_data()` 查看原始数据
2. 检查 LOG_ERROR 输出了解CRC校验失败原因
3. 验证帧结构是否符合协议规范
4. 确认转义编码/解码是否正确

## 相关文件

- `src/common/protocol.h`：协议定义头文件
- `src/common/protocol.c`：协议编解码实现
- `src/server/signal_controller.h`：信号控制机头文件
- `src/server/signal_controller.c`：帧处理逻辑实现
- `Makefile`：构建规则和测试目标

## 问题排查

如果测试失败，请检查：

1. **编译错误**：确保所有依赖的头文件和库正确链接
2. **CRC校验失败**：检查数据内容和CRC计算逻辑
3. **帧边界识别错误**：验证 FRAME_START/FRAME_END 处理逻辑
4. **内存错误**：使用 valgrind 等工具检查内存泄漏
5. **转义编码问题**：确认转义字符处理正确

通过本测试脚本，可以全面验证交通信号控制机帧处理功能的正确性和鲁棒性，确保在实际网络环境中的可靠运行。